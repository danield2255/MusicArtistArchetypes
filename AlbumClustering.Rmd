---
title: "Album Clustering"
author: "Daniel DeFoe"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE)
```

```{r, include=FALSE}
library(tidyverse)
library(ggridges)
library(ggplot2)
library(viridis)
library(RColorBrewer)
library(dplyr) 
library(mltools)
library(rlang)
library(reshape2)
library(stringi)
set.seed(41)
```


## Data Subset Creations
One dataset is made to include only the average of all the subjective spotify measures and then another is made to include more expressions(maximums and ranges) of some of these measures. 
```{r}
df = read_csv("Data/attrsOfAlbsFinal.csv")
df = within(df,  id <- paste(Album, Artist, sep="---"))

#data with all elements artist has control over when making album
dfAll = df %>%
  select(id, numSongsOnAlb, totalDurationSeconds, avgTempo, rangeTempo, moreCommonMajMin, presenceUncommonTS, totalExplicit, proportionExplicit, avgAcousticness, maxAcousticnessTrack, avgDanceability, maxDanceabilityTrack, rangeEnergy, avgEnergy, maxInstrumentalnessTrack, avgInstrumentalness, avgLiveness, maxLivenessTrack, avgLoudness, rangeLoudness, avgSpeechiness, maxSpeechinessTrack, avgValence, rangeValence)


#subset that is really just the objective data
dfObjectiveOnly = df %>%
  select(id, ReleaseYear, Genres, Gender, Group.Solo, RiaaStatus, Label, numGrammys, NumAlbums, YearFirstAlbum, popularGenres)

```



The genre of the album will be inferred by grabbing the larger, more general common genre names from the list of all the songs genres in the album. First the top 10 genres from all of the albums will be determined. Ultimately each album will be categorized with these 10 genres when applicable. We will try to establish a primary, secondary, and tertiary genre where applicable. 
```{r, include = FALSE}
dfObjectiveOnly["Genres"] = lapply(dfObjectiveOnly["Genres"], gsub, pattern = "hip hop", replacement = "hip-hop", fixed = TRUE) 


mostCommonGenres = dfObjectiveOnly["Genres"] %>%
  tolower() %>%
  str_split("(,|\\s|\")") %>%
  unlist() %>%
  table() %>%
  sort(decreasing = TRUE)

##Takes the top 10 genres
mostCommonGenres = mostCommonGenres[-1] %>%
  head(10) %>%
  names()


topGenreFinder = function(genres){
  if (is.na(genres)){
    topGenres = c("Other")
    return (topGenres)
  }
  commonGenrePresence = str_count(genres, mostCommonGenres)
  top3 = order(commonGenrePresence, decreasing = TRUE)[1:3]
  for (i in top3){
    if (commonGenrePresence[i] == 0){
      top3 = top3[top3 != i]
    }
  }
  if (is_empty(top3)){
    topGenres = c("Other")
  } else{
    topGenres = mostCommonGenres[top3]    
  }
  return (topGenres)
}


Genres = lapply(1:nrow(dfObjectiveOnly), function(rNum) { topGenreFinder(dfObjectiveOnly[rNum, "Genres"])})

genreDf = data.frame(t(sapply(Genres, `length<-`, 3)))
names(genreDf) = c("Genre1", "Genre2", "Genre3")

dfObjectiveOnly= cbind(dfObjectiveOnly,genreDf)
dfObjectiveOnly = dfObjectiveOnly %>% select(-Genres)
```




There is also data for each year on what the estimated most three most popular genres of the year were. For each album it will be determined if the album's primary genre (Genre1) was one of these three most popular. 
```{r}
dfObjectiveOnly$Genre1InYearTop = ifelse(stri_detect_fixed(dfObjectiveOnly$popularGenres, dfObjectiveOnly$Genre1), TRUE, FALSE)
```
Also, because there is data on the release year of the album and the year of the artist's first album release, it can be worthwhile to consider how long an artist has been active on each current release by calculating the years since the first album. 
```{r}
dfObjectiveOnly$YearsSinceFirst = dfObjectiveOnly$ReleaseYear - dfObjectiveOnly$YearFirstAlbum
```






## PCA
First the dataset with the complete set of spotify measures was plugged into pca. The proportion of the variance captured in each principle component is seen in the summary. Will look at the rotation of the PC's to see the loadings of the PC's to each feature. Ths will be done to really define each principle component. 
```{r}
pcaOfData = function(df){
  ids = df[,1]
  dfSub = df[,-1]
  pcas = prcomp(dfSub, center = TRUE, scale. = TRUE)
  plot(pcas)
  pcas$x = cbind(ids, data.frame(pcas$x))
  return (pcas)
}
```


First, PCA was applied to the data with all spotify metrics and the objective average metrics. 
```{r}
pcsSpotifyAndObjectives = pcaOfData(dfAll)
pcsSpotifyAndObjectives$rotation[,1:5]
```
Here we will define that the PC's as follows:
- PC1: Measure of how explicit an album is compiled with how dancable and speechy it is. 
- PC2: Measure of how low energy, low volume, high dynamic, and acoustic an album is.
- PC3: How short an album is, and how its very likely not live with also measuring how acoustic, dancable, and low energy it is.
- PC4: Measure of how long, instrumental, happy, and dancable an album is that is not live
- PC5: Measure of how short, explicit, instrumental, slow, and sad an album is.



## K-Means Clustering and Case Studies
Clustering the principle components will hopefully reduce the affect of noise in the data. 
```{r}
kMeansPipeline = function(df, numClusts){
  dataSub = as.data.frame(df)
  dataSub = dataSub[,-1]
  wss <- (nrow(dataSub)-1)*sum(apply(dataSub,2,var))
  for (i in 2:50) wss[i] <- sum(kmeans(dataSub,centers=i)$withinss)
  plot(1:50, wss, type="b", xlab="Number of Clusters",
       ylab="Within groups sum of squares")
  
  k <- kmeans(dataSub, numClusts,iter.max=1000)
  clustDf = as.data.frame(df)
  clustDf$cluster = as.factor(k$cluster)
  return(clustDf)
}
```

```{r}
artistClusterCount = function(clusterData){
  artistCounts = clusterData %>%
    separate(id, c("Album", "Artist"), "---") %>%
    select(Artist, cluster) %>%
    group_by(cluster, Artist) %>%
    summarise(countInClusts = n())
  return(artistCounts)
}
```

A function will be created to join the demographic and objective data back to the album names once they have been clustered. This will allow us to see the prevalence of traits in particular clusters. 
```{r}
###Function to rejoin two datasets
reattachData = function(clustData, objectiveData){
  newData = clustData %>%
    inner_join(objectiveData, by = "id") %>%
    distinct()
  return(newData)
}

## Groupby to count
countInClusters = function(df, cols){
  counts = df %>%
    group_by(cluster, !!!syms(cols))%>%
    summarise(countInClusts = n()) %>%
    unite(Group, cols)
  print(counts)
  return(counts)
}


# chains previous functions to make stacked bar charts showing the proportions of each group for each cluster
stackedBarByClust = function(df, vals) {
  reattachData = reattachData(df, dfObjectiveOnly)
  countOfReattached = countInClusters(reattachData, vals)
  valProportionsReattached = countOfReattached %>%
    group_by(cluster) %>%
    mutate(proportion = countInClusts/sum(countInClusts))
  
  ggplot(valProportionsReattached, aes(x = cluster, y =proportion, fill = Group), na.rm =TRUE) +
    geom_bar(position = "fill",stat = 'identity', na.rm = TRUE) +
    labs(x = "Cluster", y = "Proportion", title = paste("Distribution of ",  paste(vals, collapse = " and ") ," In Each Cluster", sep = ""))
}

numericDistributionEachClust = function(df, val){
  reattached = reattachData(df, dfObjectiveOnly)
  
  ggplot(reattached, aes_string(x = val, y ="cluster", fill = "..x.."), na.rm =TRUE) +
    geom_density_ridges_gradient(scale = .75, rel_min_height = 0.01) +
    scale_fill_viridis(option = "C") +
    labs(title = paste('Distribution of Album ', val, " Across Clusters")) +
    theme(legend.position="none")
}



```


Now functionality will be made to get average for given values in each cluster. 
```{r}
#Function to show an average metric in each cluster
avgMetricsinClusts = function(dfInput, vals){
  reattached = reattachData(dfInput, df)
  processedData = reattached %>%
    select(cluster, vals) %>% 
    mutate_at(vars(vals), funs(scale)) %>%####Values standardized before groupby and mean
    group_by(cluster) %>%
    summarise_at(vars(vals), mean) %>%
    gather(key= "Attribute", value = "Value", vals)
  
  
  ggplot(processedData, aes(x = cluster, y =Value, fill = Attribute), na.rm =TRUE) +
    geom_bar(stat="identity",position = "dodge", na.rm = TRUE) +
    labs(x = "Cluster", y = "Average Value", title = paste("Average  ",  paste(vals, collapse = " and ") ," in Each Cluster", sep = ""))
}

```




The principle components of the complete set of spotify metrics and the objective measures are clustered here using k-means. The 10 priniciple components will be available to cluster, but changing the number of top PC's we cluster on should hopefully not change the clusters too much. Different combinations of the first N principle components and different values of K will be tested to see what factors are defining the clusters most prominantly. The greatest decrease in variance explained by far is after the 2nd principle component, and the next notable decrease is between the 5th and 6th principle. For these reasons, the first 5 principle components could have potential to be the most useful; therefore, various clustering combinations using the first 5 principle components will be compared. Given a constant number of clusters K, we should expect a reasonably similar pattern in the traits of each cluster still. 

First the clustering will be done using only the 1st and 2nd principle components. The curve of the withing group sum of square error slightly suggests that the best number of clusters is 4, so that will be used. 
```{r}
first2Pcs4Clusts = kMeansPipeline(data.frame(pcsSpotifyAndObjectives$x[,1:3]), 4)
plot(pcsSpotifyAndObjectives$x[, c(2,3)], col=first2Pcs4Clusts$cluster, pch=16)
```
Some small testing of atrist album distributions across the clusters. 
```{r}
artistCount=artistClusterCount(first2Pcs4Clusts)
johnMayerAppearances = artistCount %>%
  filter(Artist == "John Mayer")
print(johnMayerAppearances)

maroon5Appearances = artistCount %>%
  filter(Artist == "Maroon 5")
print(maroon5Appearances)
```


```{r}
avgMetricsinClusts(first2Pcs4Clusts,  c("avgDanceability", "avgEnergy", "avgAcousticness", "avgSpeechiness", "avgInstrumentalness", "proportionExplicit", "avgLiveness", "avgValence", "totalDurationSeconds", "avgTempo", "moreCommonMajMin", "proportionExplicit", "avgLoudness", "avgSpeechiness"))
avgMetricsinClusts(first2Pcs4Clusts, c("avgEnergy", "avgAcousticness"))
avgMetricsinClusts(first2Pcs4Clusts, c("avgSpeechiness", "proportionExplicit"))
avgMetricsinClusts(first2Pcs4Clusts, c("numGrammys", "presenceUncommonTS"))
avgMetricsinClusts(first2Pcs4Clusts, c("numSongsOnAlb", "totalExplicit", "NumAlbums"))
avgMetricsinClusts(first2Pcs4Clusts, c("avgLoudness", "rangeLoudness"))
```

Clust1: short, low acoustic, high energy, loud, high danceability, high tempo, and high valence. There are a high number on uncommon time signature songs. 
Clust2: Low speechiness, and low explicit. Has more country 
Clust3: High danceability, very high speechiness, very high propotion explicit, low tempo. There are many solo male artists. It is high in rap albums.
Clust4: Long, high acousticness, high instrumentalness, low energy, low dancability, minor, quiet, slow, sad, and non-explicit 

```{r}
numericDistributionEachClust2 = function(df, val){
  reattached = reattachData(df, dfObjectiveOnly)
  
  ggplot(reattached, aes_string(x = val, y ="cluster"), na.rm =TRUE) +
    geom_density_ridges(alpha = 0.6, stat="binline", bins=20) +
    scale_fill_viridis(option = "C") +
    labs(title = paste('Distribution of Album ', val, " Across Clusters")) +
    theme(legend.position="none")
}
```



```{r}
stackedBarByClust(first2Pcs4Clusts, c("Gender"))
stackedBarByClust(first2Pcs4Clusts, c("Group.Solo"))
stackedBarByClust(first2Pcs4Clusts, c("Genre1"))
#stackedBarByClust(first2Pcs4Clusts, c("Gender", "Group.Solo"))
#stackedBarByClust(first2Pcs4Clusts, c("Gender", "ReleaseYear"))
#stackedBarByClust(first2Pcs4Clusts, c("Group.Solo", "ReleaseYear"))
```
```{r}
numericDistributionEachClust(first2Pcs4Clusts, 'ReleaseYear')

numericDistributionEachClust(first2Pcs4Clusts, 'YearsSinceFirst')
```

Now the first 3 principle components will be what is clustered on. The within groups sum of squares plot now shows that if may be useful to use 5 clusters. We will try using both 4 and 5 clusters to compare. The first will use 4 clusters. 
```{r}
first3Pcs4Clusts = kMeansPipeline(data.frame(pcsSpotifyAndObjectives$x[,1:4]), 4)
plot(pcsSpotifyAndObjectives$x[, c(2,3)], col=first3Pcs4Clusts$cluster, pch=16)
plot(pcsSpotifyAndObjectives$x[, c(2,4)], col=first3Pcs4Clusts$cluster, pch=16)
plot(pcsSpotifyAndObjectives$x[, c(3,4)], col=first3Pcs4Clusts$cluster, pch=16)
```

```{r}
avgMetricsinClusts(first3Pcs4Clusts,  c("avgDanceability", "avgEnergy", "avgAcousticness", "avgSpeechiness", "avgInstrumentalness", "proportionExplicit", "avgLiveness", "avgValence", "totalDurationSeconds", "avgTempo", "moreCommonMajMin", "proportionExplicit", "avgLoudness", "avgSpeechiness"))
avgMetricsinClusts(first3Pcs4Clusts, c("avgEnergy", "avgAcousticness"))
avgMetricsinClusts(first3Pcs4Clusts, c("avgSpeechiness", "proportionExplicit"))
avgMetricsinClusts(first3Pcs4Clusts, c("numGrammys", "presenceUncommonTS"))
avgMetricsinClusts(first3Pcs4Clusts, c("numSongsOnAlb", "totalExplicit", "NumAlbums"))
avgMetricsinClusts(first3Pcs4Clusts, c("avgLoudness", "rangeLoudness"))
```
It seems that the addition of the third PC helps define another cluster (here cluster 2) as long, instrumentally full, live albums. This is a good sign because PC 3 had a great opinion about liveness. 

```{r}
stackedBarByClust(first3Pcs4Clusts, c("Gender"))
stackedBarByClust(first3Pcs4Clusts, c("Group.Solo"))
stackedBarByClust(first3Pcs4Clusts, c("Genre1"))
#stackedBarByClust(first3Pcs4Clusts, c("Gender", "Group.Solo"))
#stackedBarByClust(first3Pcs4Clusts, c("Gender", "ReleaseYear"))
#stackedBarByClust(first3Pcs4Clusts, c("Group.Solo", "ReleaseYear"))
```

```{r}
numericDistributionEachClust(first3Pcs4Clusts, 'ReleaseYear')

numericDistributionEachClust(first3Pcs4Clusts, 'YearsSinceFirst')
```


Now the same 3 principle components with 5 clusters. 
```{r}
first3Pcs5Clusts = kMeansPipeline(data.frame(pcsSpotifyAndObjectives$x[,1:4]), 5)
plot(pcsSpotifyAndObjectives$x[, c(2,3)], col=first3Pcs5Clusts$cluster, pch=16)
plot(pcsSpotifyAndObjectives$x[, c(2,4)], col=first3Pcs5Clusts$cluster, pch=16)
plot(pcsSpotifyAndObjectives$x[, c(3,4)], col=first3Pcs5Clusts$cluster, pch=16)
```


```{r}
avgMetricsinClusts(first3Pcs5Clusts,  c("avgDanceability", "avgEnergy", "avgAcousticness", "avgSpeechiness", "avgInstrumentalness", "proportionExplicit", "avgLiveness", "avgValence", "totalDurationSeconds", "avgTempo", "moreCommonMajMin", "proportionExplicit", "avgLoudness", "avgSpeechiness"))
avgMetricsinClusts(first3Pcs5Clusts, c("avgEnergy", "avgAcousticness"))
avgMetricsinClusts(first3Pcs5Clusts, c("avgSpeechiness", "proportionExplicit"))
avgMetricsinClusts(first3Pcs5Clusts, c("numGrammys", "presenceUncommonTS"))
avgMetricsinClusts(first3Pcs5Clusts, c("numSongsOnAlb", "totalExplicit", "NumAlbums"))
avgMetricsinClusts(first3Pcs5Clusts, c("avgLoudness", "rangeLoudness"))
```
The addition of a 5th cluster does not show predominant traits right away, and it can be that this "added cluster" is cluster 4, with all of its levels pretty close to 0. However, the genre distribution plot below shows there may be better separation of genres.

```{r}
stackedBarByClust(first3Pcs5Clusts, c("Gender"))
stackedBarByClust(first3Pcs5Clusts, c("Group.Solo"))
stackedBarByClust(first3Pcs5Clusts, c("Genre1"))
#stackedBarByClust(first3Pcs5Clusts, c("Gender", "Group.Solo"))
#stackedBarByClust(first3Pcs5Clusts, c("Gender", "ReleaseYear"))
#stackedBarByClust(first3Pcs5Clusts, c("Group.Solo", "ReleaseYear"))
```

```{r}
numericDistributionEachClust(first3Pcs5Clusts, 'ReleaseYear')

numericDistributionEachClust(first3Pcs5Clusts, 'YearsSinceFirst')
```


Now the first 5 principle components will be clustered on. First 4 clusters will be used. 
```{r}
first5Pcs4Clusts = kMeansPipeline(data.frame(pcsSpotifyAndObjectives$x[,1:6]), 4)
plot(pcsSpotifyAndObjectives$x[, c(2,3)], col=first5Pcs4Clusts$cluster, pch=16)
plot(pcsSpotifyAndObjectives$x[, c(2,4)], col=first5Pcs4Clusts$cluster, pch=16)
plot(pcsSpotifyAndObjectives$x[, c(2,5)], col=first5Pcs4Clusts$cluster, pch=16)
plot(pcsSpotifyAndObjectives$x[, c(2,6)], col=first5Pcs4Clusts$cluster, pch=16)
plot(pcsSpotifyAndObjectives$x[, c(3,4)], col=first5Pcs4Clusts$cluster, pch=16)
plot(pcsSpotifyAndObjectives$x[, c(3,5)], col=first5Pcs4Clusts$cluster, pch=16)
plot(pcsSpotifyAndObjectives$x[, c(3,6)], col=first5Pcs4Clusts$cluster, pch=16)
plot(pcsSpotifyAndObjectives$x[, c(4,5)], col=first5Pcs4Clusts$cluster, pch=16)
plot(pcsSpotifyAndObjectives$x[, c(4,6)], col=first5Pcs4Clusts$cluster, pch=16)
plot(pcsSpotifyAndObjectives$x[, c(5,6)], col=first5Pcs4Clusts$cluster, pch=16)
```

```{r}
avgMetricsinClusts(first5Pcs4Clusts,  c("avgDanceability", "avgEnergy", "avgAcousticness", "avgSpeechiness", "avgInstrumentalness", "proportionExplicit", "avgLiveness", "avgValence", "totalDurationSeconds", "avgTempo", "moreCommonMajMin", "proportionExplicit", "avgLoudness", "avgSpeechiness"))
avgMetricsinClusts(first5Pcs4Clusts, c("avgEnergy", "avgAcousticness"))
avgMetricsinClusts(first5Pcs4Clusts, c("avgSpeechiness", "proportionExplicit"))
avgMetricsinClusts(first5Pcs4Clusts, c("numGrammys", "presenceUncommonTS"))
avgMetricsinClusts(first5Pcs4Clusts, c("numSongsOnAlb", "totalExplicit", "NumAlbums"))
avgMetricsinClusts(first5Pcs4Clusts, c("avgLoudness", "rangeLoudness"))
```
Here it seems that the first 5 PC's give virtually the same results as the first 3. This is a good result for the sake of reliability of 4 clusters doing a good job at separating the data. 

```{r}
stackedBarByClust(first5Pcs4Clusts, c("Gender"))
stackedBarByClust(first5Pcs4Clusts, c("Group.Solo"))
stackedBarByClust(first5Pcs4Clusts, c("Genre1"))
#stackedBarByClust(first5Pcs4Clusts, c("Gender", "Group.Solo"))
#stackedBarByClust(first5Pcs4Clusts, c("Gender", "ReleaseYear"))
#stackedBarByClust(first5Pcs4Clusts, c("Group.Solo", "ReleaseYear"))
```

```{r}
numericDistributionEachClust(first5Pcs4Clusts, 'ReleaseYear')

numericDistributionEachClust(first5Pcs4Clusts, 'YearsSinceFirst')
```



The number of clusters will be increased until 7. Here is 5.
```{r}
first5Pcs5Clusts = kMeansPipeline(data.frame(pcsSpotifyAndObjectives$x[,1:6]), 5)
plot(pcsSpotifyAndObjectives$x[, c(2,3)], col=first5Pcs5Clusts$cluster, pch=16)
plot(pcsSpotifyAndObjectives$x[, c(2,4)], col=first5Pcs5Clusts$cluster, pch=16)
plot(pcsSpotifyAndObjectives$x[, c(2,5)], col=first5Pcs5Clusts$cluster, pch=16)
plot(pcsSpotifyAndObjectives$x[, c(2,6)], col=first5Pcs5Clusts$cluster, pch=16)
plot(pcsSpotifyAndObjectives$x[, c(3,4)], col=first5Pcs5Clusts$cluster, pch=16)
plot(pcsSpotifyAndObjectives$x[, c(3,5)], col=first5Pcs5Clusts$cluster, pch=16)
plot(pcsSpotifyAndObjectives$x[, c(3,6)], col=first5Pcs5Clusts$cluster, pch=16)
plot(pcsSpotifyAndObjectives$x[, c(4,5)], col=first5Pcs5Clusts$cluster, pch=16)
plot(pcsSpotifyAndObjectives$x[, c(4,6)], col=first5Pcs5Clusts$cluster, pch=16)
plot(pcsSpotifyAndObjectives$x[, c(5,6)], col=first5Pcs5Clusts$cluster, pch=16)
```

```{r}
avgMetricsinClusts(first5Pcs5Clusts,  c("avgDanceability", "avgEnergy", "avgAcousticness", "avgSpeechiness", "avgInstrumentalness", "proportionExplicit", "avgLiveness", "avgValence", "totalDurationSeconds", "avgTempo", "moreCommonMajMin", "proportionExplicit", "avgLoudness", "avgSpeechiness"))
avgMetricsinClusts(first5Pcs5Clusts, c("avgEnergy", "avgAcousticness"))
avgMetricsinClusts(first5Pcs5Clusts, c("avgSpeechiness", "proportionExplicit"))
avgMetricsinClusts(first5Pcs5Clusts, c("numGrammys", "presenceUncommonTS"))
avgMetricsinClusts(first5Pcs5Clusts, c("numSongsOnAlb", "totalExplicit", "NumAlbums"))
avgMetricsinClusts(first5Pcs5Clusts, c("avgLoudness", "rangeLoudness"))
```


```{r}
stackedBarByClust(first5Pcs5Clusts, c("Gender"))
stackedBarByClust(first5Pcs5Clusts, c("Group.Solo"))
stackedBarByClust(first5Pcs5Clusts, c("Genre1"))
#stackedBarByClust(first5Pcs5Clusts, c("Gender", "Group.Solo"))
#stackedBarByClust(first5Pcs5Clusts, c("Gender", "ReleaseYear"))
#stackedBarByClust(first5Pcs5Clusts, c("Group.Solo", "ReleaseYear"))
```

```{r}
numericDistributionEachClust(first5Pcs5Clusts, 'ReleaseYear')

numericDistributionEachClust(first5Pcs5Clusts, 'YearsSinceFirst')
```

Now with 6 clusters.
```{r}
first5Pcs6Clusts = kMeansPipeline(data.frame(pcsSpotifyAndObjectives$x[,1:6]), 6)
plot(pcsSpotifyAndObjectives$x[, c(2,3)], col=first5Pcs6Clusts$cluster, pch=16)
plot(pcsSpotifyAndObjectives$x[, c(2,4)], col=first5Pcs6Clusts$cluster, pch=16)
plot(pcsSpotifyAndObjectives$x[, c(2,5)], col=first5Pcs6Clusts$cluster, pch=16)
plot(pcsSpotifyAndObjectives$x[, c(2,6)], col=first5Pcs6Clusts$cluster, pch=16)
plot(pcsSpotifyAndObjectives$x[, c(3,4)], col=first5Pcs6Clusts$cluster, pch=16)
plot(pcsSpotifyAndObjectives$x[, c(3,5)], col=first5Pcs6Clusts$cluster, pch=16)
plot(pcsSpotifyAndObjectives$x[, c(3,6)], col=first5Pcs6Clusts$cluster, pch=16)
plot(pcsSpotifyAndObjectives$x[, c(4,5)], col=first5Pcs6Clusts$cluster, pch=16)
plot(pcsSpotifyAndObjectives$x[, c(4,6)], col=first5Pcs6Clusts$cluster, pch=16)
plot(pcsSpotifyAndObjectives$x[, c(5,6)], col=first5Pcs6Clusts$cluster, pch=16)
```

```{r}
avgMetricsinClusts(first5Pcs6Clusts,  c("avgDanceability", "avgEnergy", "avgAcousticness", "avgSpeechiness", "avgInstrumentalness", "proportionExplicit", "avgLiveness", "avgValence", "totalDurationSeconds", "avgTempo", "moreCommonMajMin", "proportionExplicit", "avgLoudness", "avgSpeechiness"))
avgMetricsinClusts(first5Pcs6Clusts, c("avgEnergy", "avgAcousticness"))
avgMetricsinClusts(first5Pcs6Clusts, c("avgSpeechiness", "proportionExplicit"))
avgMetricsinClusts(first5Pcs6Clusts, c("numGrammys", "presenceUncommonTS"))
avgMetricsinClusts(first5Pcs6Clusts, c("numSongsOnAlb", "totalExplicit", "NumAlbums"))
avgMetricsinClusts(first5Pcs6Clusts, c("avgLoudness", "rangeLoudness"))
```

```{r}
stackedBarByClust(first5Pcs6Clusts, c("Gender"))
stackedBarByClust(first5Pcs6Clusts, c("Group.Solo"))
stackedBarByClust(first5Pcs6Clusts, c("Genre1"))
#stackedBarByClust(first5Pcs6Clusts, c("Gender", "Group.Solo"))
#stackedBarByClust(first5Pcs6Clusts, c("Gender", "ReleaseYear"))
#stackedBarByClust(first5Pcs6Clusts, c("Group.Solo", "ReleaseYear"))
```

```{r}
numericDistributionEachClust(first5Pcs6Clusts, 'ReleaseYear')

numericDistributionEachClust(first5Pcs6Clusts, 'YearsSinceFirst')
```

Now with 7. 
```{r}
first5Pcs7Clusts = kMeansPipeline(data.frame(pcsSpotifyAndObjectives$x[,1:6]), 7)
plot(pcsSpotifyAndObjectives$x[, c(2,3)], col=first5Pcs7Clusts$cluster, pch=16)
plot(pcsSpotifyAndObjectives$x[, c(2,4)], col=first5Pcs7Clusts$cluster, pch=16)
plot(pcsSpotifyAndObjectives$x[, c(2,5)], col=first5Pcs7Clusts$cluster, pch=16)
plot(pcsSpotifyAndObjectives$x[, c(2,6)], col=first5Pcs7Clusts$cluster, pch=16)
plot(pcsSpotifyAndObjectives$x[, c(3,4)], col=first5Pcs7Clusts$cluster, pch=16)
plot(pcsSpotifyAndObjectives$x[, c(3,5)], col=first5Pcs7Clusts$cluster, pch=16)
plot(pcsSpotifyAndObjectives$x[, c(3,6)], col=first5Pcs7Clusts$cluster, pch=16)
plot(pcsSpotifyAndObjectives$x[, c(4,5)], col=first5Pcs7Clusts$cluster, pch=16)
plot(pcsSpotifyAndObjectives$x[, c(4,6)], col=first5Pcs7Clusts$cluster, pch=16)
plot(pcsSpotifyAndObjectives$x[, c(5,6)], col=first5Pcs7Clusts$cluster, pch=16)
```

```{r}
avgMetricsinClusts(first5Pcs7Clusts,  c("avgDanceability", "avgEnergy", "avgAcousticness", "avgSpeechiness", "avgInstrumentalness", "proportionExplicit", "avgLiveness", "avgValence", "totalDurationSeconds", "avgTempo", "moreCommonMajMin", "proportionExplicit", "avgLoudness", "avgSpeechiness"))
avgMetricsinClusts(first5Pcs7Clusts, c("avgEnergy", "avgAcousticness"))
avgMetricsinClusts(first5Pcs7Clusts, c("avgSpeechiness", "proportionExplicit"))
avgMetricsinClusts(first5Pcs7Clusts, c("numGrammys", "presenceUncommonTS"))
avgMetricsinClusts(first5Pcs7Clusts, c("numSongsOnAlb", "totalExplicit", "NumAlbums"))
avgMetricsinClusts(first5Pcs7Clusts, c("avgLoudness", "rangeLoudness"))
```

```{r}
stackedBarByClust(first5Pcs7Clusts, c("Gender"))
stackedBarByClust(first5Pcs7Clusts, c("Group.Solo"))
stackedBarByClust(first5Pcs7Clusts, c("Genre1"))
#stackedBarByClust(first7Pcs5Clusts, c("Gender", "Group.Solo"))
#stackedBarByClust(first7Pcs5Clusts, c("Gender", "ReleaseYear"))
#stackedBarByClust(first7Pcs5Clusts, c("Group.Solo", "ReleaseYear"))
```

```{r}
numericDistributionEachClust(first5Pcs7Clusts, 'ReleaseYear')

numericDistributionEachClust(first5Pcs7Clusts, 'YearsSinceFirst')
```




























