---
title: "Album Clustering"
author: "Daniel DeFoe"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE)
```

```{r, include=FALSE}
library(tidyverse)
library(ggridges)
library(ggplot2)
library(viridis)
library(RColorBrewer)
library(dplyr) 
library(mltools)
library(rlang)
library(reshape2)
library(stringi)
set.seed(41)
```


## Data Subset Creations
One dataset is made to include only the average of all the subjective spotify measures and then another is made to include more expressions(maximums and ranges) of some of these measures. 
```{r}
df = read_csv("Data/attrsOfAlbsFinal.csv")
df = within(df,  id <- paste(Album, Artist, sep="---"))

#data with all elements artist has control over when making album
dfAll = df %>%
  select(id, numSongsOnAlb, totalDurationSeconds, avgTempo, rangeTempo, moreCommonMajMin, presenceUncommonTS, totalExplicit, proportionExplicit, avgAcousticness, maxAcousticnessTrack, avgDanceability, maxDanceabilityTrack, rangeEnergy, avgEnergy, maxInstrumentalnessTrack, avgInstrumentalness, avgLiveness, maxLivenessTrack, avgLoudness, rangeLoudness, avgSpeechiness, maxSpeechinessTrack, avgValence, rangeValence)


#subset that is really just the objective data
dfObjectiveOnly = df %>%
  select(id, ReleaseYear, Genres, Gender, Group.Solo, RiaaStatus, Label, numGrammys, NumAlbums, YearFirstAlbum, popularGenres)

```



The genre of the album will be inferred by grabbing the larger, more general common genre names from the list of all the songs genres in the album. First the top 10 genres from all of the albums will be determined. Ultimately each album will be categorized with these 10 genres when applicable. We will try to establish a primary, secondary, and tertiary genre where applicable. 
```{r, include = FALSE}
dfObjectiveOnly["Genres"] = lapply(dfObjectiveOnly["Genres"], gsub, pattern = "hip hop", replacement = "hip-hop", fixed = TRUE) 


mostCommonGenres = dfObjectiveOnly["Genres"] %>%
  tolower() %>%
  str_split("(,|\\s|\")") %>%
  unlist() %>%
  table() %>%
  sort(decreasing = TRUE)

##Takes the top 10 genres
mostCommonGenres = mostCommonGenres[-1] %>%
  head(10) %>%
  names()


commonGenreFinder = function(genres){
  if (is.na(genres)){
    return ("Other")
  }
  commonGenrePresence = str_count(genres, mostCommonGenres)
  present = mostCommonGenres[commonGenrePresence != 0]
  ret = stri_paste(present, collapse = ", ")
  if (length(ret) < 1){
    return ("Other")
  }
  return (ret)
}

topGenreFinder = function(genres){
  if (is.na(genres)){
    topGenres = c("Other")
    return (topGenres)
  }
  commonGenrePresence = str_count(genres, mostCommonGenres)
  top3 = order(commonGenrePresence, decreasing = TRUE)[1:3]
  for (i in top3){
    if (commonGenrePresence[i] == 0){
      top3 = top3[top3 != i]
    }
  }
  if (is_empty(top3)){
    topGenres = c("Other")
  } else{
    topGenres = mostCommonGenres[top3]    
  }
  return (topGenres)
}


Genres = lapply(1:nrow(dfObjectiveOnly), function(rNum) { topGenreFinder(dfObjectiveOnly[rNum, "Genres"])})

genreDf = data.frame(t(sapply(Genres, `length<-`, 3)))
names(genreDf) = c("Genre1", "Genre2", "Genre3")

dfObjectiveOnly= cbind(dfObjectiveOnly,genreDf)
dfObjectiveOnly = dfObjectiveOnly %>% select(-Genres)
```






## PCA
First the dataset with the complete set of spotify measures was plugged into pca. The proportion of the variance captured in each principle component is seen in the summary. Will look at the rotation of the PC's to see the loadings of the PC's to each feature. Ths will be done to really define each principle component. 
```{r}
pcaOfData = function(df){
  ids = df[,1]
  dfSub = df[,-1]
  pcas = prcomp(dfSub, center = TRUE, scale. = TRUE)
  plot(pcas)
  pcas$x = cbind(ids, data.frame(pcas$x))
  return (pcas)
}
```


First, PCA was applied to the data with all spotify metrics and the objective average metrics. 
```{r}
pcsSpotifyAndObjectives = pcaOfData(dfAll)
pcsSpotifyAndObjectives$rotation[,1:5]
```
Here we will define that the PC's as follows:
- PC1: Measure of how explicit an album is compiled with how dancable and speechy it is. 
- PC2: Measure of how low energy, low volume, high dynamic, and acoustic an album is.
- PC3: How short an album is, and how its very likely not live with also measuring how acoustic, dancable, and low energy it is.
- PC4: Measure of how long, instrumental, happy, and dancable an album is that is not live
- PC5: Measure of how short, explicit, instrumental, slow, and sad an album is.



## K-Means Clustering and Case Studies
Clustering the principle components will hopefully reduce the affect of noise in the data. 
```{r}
kMeansPipeline = function(df, numClusts){
  dataSub = as.data.frame(df)
  dataSub = dataSub[,-1]
  wss <- (nrow(dataSub)-1)*sum(apply(dataSub,2,var))
  for (i in 2:50) wss[i] <- sum(kmeans(dataSub,centers=i)$withinss)
  plot(1:50, wss, type="b", xlab="Number of Clusters",
       ylab="Within groups sum of squares")
  
  k <- kmeans(dataSub, numClusts,iter.max=1000)
  clustDf = as.data.frame(df)
  clustDf$cluster = as.factor(k$cluster)
  return(clustDf)
}
```

```{r}
artistClusterCount = function(clusterData){
  artistCounts = clusterData %>%
    separate(id, c("Album", "Artist"), "---") %>%
    select(Artist, cluster) %>%
    group_by(cluster, Artist) %>%
    summarise(countInClusts = n())
  return(artistCounts)
}
```

A function will be created to join the demographic and objective data back to the album names once they have been clustered. This will allow us to see the prevalence of traits in particular clusters. 
```{r}
###Function to rejoin two datasets
reattachData = function(clustData, objectiveData){
  newData = clustData %>%
    inner_join(objectiveData, by = "id") %>%
    distinct()
  return(newData)
}

## Groupby to count
countInClusters = function(df, cols){
  counts = df %>%
    group_by(cluster, !!!syms(cols))%>%
    summarise(countInClusts = n()) %>%
    unite(Group, cols)
  print(counts)
  return(counts)
}


# chains previous functions to make stacked bar charts showing the proportions of each group for each cluster
stackedBarByClust = function(df, vals) {
  reattachData = reattachData(df, dfObjectiveOnly)
  countOfReattached = countInClusters(reattachData, vals)
  valProportionsReattached = countOfReattached %>%
    group_by(cluster) %>%
    mutate(proportion = countInClusts/sum(countInClusts))
  
  ggplot(valProportionsReattached, aes(x = cluster, y =proportion, fill = Group), na.rm =TRUE) +
    geom_bar(position = "fill",stat = 'identity', na.rm = TRUE) +
    labs(x = "Cluster", y = "Proportion", title = paste("Distribution of ",  paste(vals, collapse = " and ") ," In Each Cluster", sep = ""))
}

numericDistributionEachClust = function(df, val){
  reattached = reattachData(df, dfObjectiveOnly)
  
  ggplot(reattached, aes_string(x = val, y ="cluster", fill = "..x.."), na.rm =TRUE) +
    geom_density_ridges_gradient(scale = .75, rel_min_height = 0.01) +
    scale_fill_viridis(option = "C") +
    labs(title = paste('Distribution of Album ', val, " Across Clusters")) +
    theme(legend.position="none")
}

```


Now functionality will be made to get average for given values in each cluster. 
```{r}
#Function to show an average metric in each cluster
avgMetricsinClusts = function(dfInput, vals){
  reattached = reattachData(dfInput, df)
  processedData = reattached %>%
    select(cluster, vals) %>% 
    mutate_at(vars(vals), funs(scale)) %>%####Values standardized before groupby and mean
    group_by(cluster) %>%
    summarise_at(vars(vals), mean) %>%
    gather(key= "Attribute", value = "Value", vals)
  
  
  ggplot(processedData, aes(x = cluster, y =Value, fill = Attribute), na.rm =TRUE) +
    geom_bar(stat="identity",position = "dodge", na.rm = TRUE) +
    labs(x = "Cluster", y = "Average Value", title = paste("Average  ",  paste(vals, collapse = " and ") ," in Each Cluster", sep = ""))
}

```




The principle components of the complete set of spotify metrics and the objective measures are clustered here using k-means. The 10 priniciple components will be available to cluster, but changing the number of top PC's we cluster on should hopefully not change the clusters too much. Different combinations of the first N principle components and different values of K will be tested to see what factors are defining the clusters most prominantly. The greatest decrease in variance explained by far is after the 2nd principle component, and the next notable decrease is between the 5th and 6th principle. For these reasons, the first 5 principle components could have potential to be the most useful; therefore, various clustering combinations using the first 5 principle components will be compared. Given a constant number of clusters K, we should expect a reasonably similar pattern in the traits of each cluster still. 

First the clustering will be done using only the 1st and 2nd principle components. The curve of the withing group sum of square error slightly suggests that the best number of clusters is 4, so that will be used. 
```{r}
first2Pcs4Clusts = kMeansPipeline(data.frame(pcsSpotifyAndObjectives$x[,1:3]), 4)
plot(pcsSpotifyAndObjectives$x[, c(2,3)], col=first2Pcs4Clusts$cluster, pch=16)
```
Some small testing of atrist album distributions across the clusters. 
```{r}
artistCount=artistClusterCount(first2Pcs4Clusts)
johnMayerAppearances = artistCount %>%
  filter(Artist == "John Mayer")
print(johnMayerAppearances)

maroon5Appearances = artistCount %>%
  filter(Artist == "Maroon 5")
print(maroon5Appearances)
```


```{r}
avgMetricsinClusts(first2Pcs4Clusts, c("avgDanceability", "avgEnergy", "avgAcousticness", "avgSpeechiness", "avgInstrumentalness", "presenceUncommonTS", "proportionExplicit", "avgLiveness", "avgValence", "rangeValence", "numSongsOnAlb", "totalDurationSeconds", "avgTempo", "rangeTempo", "moreCommonMajMin", "proportionExplicit", "avgLoudness", "avgSpeechiness"))
avgMetricsinClusts(first2Pcs4Clusts, c("avgEnergy", "avgAcousticness"))
avgMetricsinClusts(first2Pcs4Clusts, c("avgSpeechiness", "proportionExplicit"))
avgMetricsinClusts(first2Pcs4Clusts, c("numGrammys", "presenceUncommonTS"))
avgMetricsinClusts(first2Pcs4Clusts, c("numSongsOnAlb", "totalExplicit", "NumAlbums"))
avgMetricsinClusts(first2Pcs4Clusts, c("avgLoudness", "rangeLoudness"))
```

```{r}

numericDistributionEachClust(first2Pcs4Clusts, 'ReleaseYear')
```



```{r}
stackedBarByClust(first2Pcs4Clusts, c("Gender"))
stackedBarByClust(first2Pcs4Clusts, c("Group.Solo"))
stackedBarByClust(first2Pcs4Clusts, c("ReleaseYear"))
#stackedBarByClust(first2Pcs4Clusts, c("Gender", "Group.Solo"))
#stackedBarByClust(first2Pcs4Clusts, c("Gender", "ReleaseYear"))
#stackedBarByClust(first2Pcs4Clusts, c("Group.Solo", "ReleaseYear"))
```

Now the first 3 principle components will be what is clustered on. The within groups sum of squares plot now shows that if may be useful to use 5 clusters. We will try using both 4 and 5 clusters to compare. The first will use 4 clusters. 
```{r}
first3Pcs4Clusts = kMeansPipeline(data.frame(pcsSpotifyAndObjectives$x[,1:4]), 4)
plot(pcsSpotifyAndObjectives$x[, c(2,3)], col=first3Pcs4Clusts$cluster, pch=16)
```

```{r}
avgMetricsinClusts(first3Pcs4Clusts, c("avgDanceability", "avgEnergy", "avgAcousticness", "avgSpeechiness", "avgInstrumentalness", "presenceUncommonTS", "proportionExplicit", "avgLiveness", "avgValence", "rangeValence", "numSongsOnAlb", "totalDurationSeconds", "avgTempo", "rangeTempo", "moreCommonMajMin", "proportionExplicit", "avgLoudness", "avgSpeechiness"))
avgMetricsinClusts(first3Pcs4Clusts, c("avgEnergy", "avgAcousticness"))
avgMetricsinClusts(first3Pcs4Clusts, c("avgSpeechiness", "proportionExplicit"))
avgMetricsinClusts(first3Pcs4Clusts, c("numGrammys", "presenceUncommonTS"))
avgMetricsinClusts(first3Pcs4Clusts, c("numSongsOnAlb", "totalExplicit", "NumAlbums"))
avgMetricsinClusts(first3Pcs4Clusts, c("avgLoudness", "rangeLoudness"))
```


```{r}
stackedBarByClust(first3Pcs4Clusts, c("Gender"))
stackedBarByClust(first3Pcs4Clusts, c("Group.Solo"))
stackedBarByClust(first3Pcs4Clusts, c("ReleaseYear"))
#stackedBarByClust(first3Pcs4Clusts, c("Gender", "Group.Solo"))
#stackedBarByClust(first3Pcs4Clusts, c("Gender", "ReleaseYear"))
#stackedBarByClust(first3Pcs4Clusts, c("Group.Solo", "ReleaseYear"))
```


Now the same 3 principle components with 5 clusters. 
```{r}
first3Pcs5Clusts = kMeansPipeline(data.frame(pcsSpotifyAndObjectives$x[,1:4]), 5)
plot(pcsSpotifyAndObjectives$x[, c(2,3)], col=first3Pcs5Clusts$cluster, pch=16)
```
```{r}
head(dfAll)
```


```{r}
avgMetricsinClusts(first3Pcs5Clusts, c("avgDanceability", "avgEnergy", "avgAcousticness", "avgSpeechiness", "avgInstrumentalness", "presenceUncommonTS", "proportionExplicit", "avgLiveness", "avgValence", "rangeValence", "numSongsOnAlb", "totalDurationSeconds", "avgTempo", "rangeTempo", "moreCommonMajMin", "proportionExplicit", "avgLoudness", "avgSpeechiness"))
avgMetricsinClusts(first3Pcs5Clusts, c("avgEnergy", "avgAcousticness"))
avgMetricsinClusts(first3Pcs5Clusts, c("avgSpeechiness", "proportionExplicit"))
avgMetricsinClusts(first3Pcs5Clusts, c("numGrammys", "presenceUncommonTS"))
avgMetricsinClusts(first3Pcs5Clusts, c("numSongsOnAlb", "totalExplicit", "NumAlbums"))
avgMetricsinClusts(first3Pcs5Clusts, c("avgLoudness", "rangeLoudness"))
```


```{r}
stackedBarByClust(first3Pcs5Clusts, c("Gender"))
stackedBarByClust(first3Pcs5Clusts, c("Group.Solo"))
stackedBarByClust(first3Pcs5Clusts, c("ReleaseYear"))
#stackedBarByClust(first3Pcs5Clusts, c("Gender", "Group.Solo"))
#stackedBarByClust(first3Pcs5Clusts, c("Gender", "ReleaseYear"))
#stackedBarByClust(first3Pcs5Clusts, c("Group.Solo", "ReleaseYear"))
```




Now the first 5 principle components will be clustered on. 
```{r}
first5Pcs4Clusts = kMeansPipeline(data.frame(pcsSpotifyAndObjectives$x[,1:6]), 4)
plot(pcsSpotifyAndObjectives$x[, c(2,3)], col=first5Pcs4Clusts$cluster, pch=16)
```

```{r}
avgMetricsinClusts(first5Pcs4Clusts, c("avgDanceability", "avgEnergy", "avgAcousticness", "avgSpeechiness", "avgInstrumentalness", "presenceUncommonTS", "proportionExplicit", "avgLiveness", "avgValence", "rangeValence", "numSongsOnAlb", "totalDurationSeconds", "avgTempo", "rangeTempo", "moreCommonMajMin", "proportionExplicit", "avgLoudness", "avgSpeechiness"))
avgMetricsinClusts(first5Pcs4Clusts, c("avgEnergy", "avgAcousticness"))
avgMetricsinClusts(first5Pcs4Clusts, c("avgSpeechiness", "proportionExplicit"))
avgMetricsinClusts(first5Pcs4Clusts, c("numGrammys", "presenceUncommonTS"))
avgMetricsinClusts(first5Pcs4Clusts, c("numSongsOnAlb", "totalExplicit", "NumAlbums"))
avgMetricsinClusts(first5Pcs4Clusts, c("avgLoudness", "rangeLoudness"))
```


```{r}
stackedBarByClust(first5Pcs4Clusts, c("Gender"))
stackedBarByClust(first5Pcs4Clusts, c("Group.Solo"))
stackedBarByClust(first5Pcs4Clusts, c("ReleaseYear"))
#stackedBarByClust(first5Pcs4Clusts, c("Gender", "Group.Solo"))
#stackedBarByClust(first5Pcs4Clusts, c("Gender", "ReleaseYear"))
#stackedBarByClust(first5Pcs4Clusts, c("Group.Solo", "ReleaseYear"))
```










