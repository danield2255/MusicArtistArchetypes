---
title: "Album Clustering"
author: "Daniel DeFoe"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE)
```

```{r, include=FALSE}
library(tidyverse)
library(ggplot2)
library(RColorBrewer)
library(dplyr) 
library(mltools)
library(rlang)
library(reshape2)
library(stringi)
set.seed(41)
```


## Data Subset Creations
One dataset is made to include only the average of all the subjective spotify measures and then another is made to include more expressions(maximums and ranges) of some of these measures. 
```{r, include=FALSE}
df = read_csv("Data/attrsOfAlbsFinal.csv")
df = within(df,  id <- paste(Album, Artist, sep="---"))

head(df)
#data of only average spotify metrics
dfSpotifySubMetrics = df %>%
  select(id, avgAcousticness, avgDanceability, avgEnergy, avgInstrumentalness, avgLiveness, avgLoudness, avgSpeechiness, avgValence)

# data with appropriate measures of spotify metrics (averages, max, ranges)
dfSpotifyAllMeasures = df %>%
  select(id, avgAcousticness, maxAcousticnessTrack, avgDanceability, maxDanceabilityTrack, rangeEnergy, avgEnergy, maxInstrumentalnessTrack, avgInstrumentalness, avgLiveness, maxLivenessTrack, avgLoudness, rangeLoudness, avgSpeechiness, maxSpeechinessTrack, avgValence, rangeValence)

#data with all spotify metrics and some objective measures
dfSpotifyAndMusicData = df %>%
  select(id, numSongsOnAlb, totalDurationSeconds, avgTempo, rangeTempo, moreCommonMajMin, presenceUncommonTS, totalExplicit, proportionExplicit, avgAcousticness, maxAcousticnessTrack, avgDanceability, maxDanceabilityTrack, rangeEnergy, avgEnergy, maxInstrumentalnessTrack, avgInstrumentalness, avgLiveness, maxLivenessTrack, avgLoudness, rangeLoudness, avgSpeechiness, maxSpeechinessTrack, avgValence, rangeValence)

#data with all 
dfAll = df %>%
  select(id, Gender, Group.Solo, RiaaStatus, Label, numGrammys, numSongsOnAlb, totalDurationSeconds, avgTempo, rangeTempo, moreCommonMajMin, presenceUncommonTS, totalExplicit, proportionExplicit, avgAcousticness, maxAcousticnessTrack, avgDanceability, maxDanceabilityTrack, rangeEnergy, avgEnergy, maxInstrumentalnessTrack, avgInstrumentalness, avgLiveness, maxLivenessTrack, avgLoudness, rangeLoudness, avgSpeechiness, maxSpeechinessTrack, avgValence, rangeValence)


#subset that is really just the objective data
dfObjectiveOnly = df %>%
  select(id, ReleaseYear, Genres, Gender, Group.Solo, RiaaStatus, Label, numGrammys, numSongsOnAlb, totalDurationSeconds)

```

The genre of the album will be inferred by grabbing the larger, more general common genre names from the list of all the songs genres in the album. First the top 10 genres from all of the albums will be determined. Ultimately each album will be categorized with these 10 genres when applicable. 
```{r, include=FALSE}
dfObjectiveOnly["Genres"] = lapply(dfObjectiveOnly["Genres"], gsub, pattern = "hip hop", replacement = "hip-hop", fixed = TRUE) 

mostCommonGenres = dfObjectiveOnly["Genres"] %>%
  tolower() %>%
  str_split("(,|\\s|\")") %>%
  unlist() %>%
  table() %>%
  sort(decreasing = TRUE)

##Takes the top 10 genres
mostCommonGenres = mostCommonGenres[-1] %>%
  head(10) %>%
  names()

commonGenreFinder = function(genres){
  if (is.na(genres)){
    return ("Other")
  }
  commonGenrePresence = str_count(genres, mostCommonGenres)
  present = mostCommonGenres[commonGenrePresence != 0]
  ret = stri_paste(present, collapse = ", ")
  if (length(ret) < 1){
    return ("Other")
  }
  return (ret)
}


GeneralGenres = lapply(1:nrow(dfObjectiveOnly), function(rNum) { commonGenreFinder(dfObjectiveOnly[rNum, "Genres"])})
dfObjectiveOnly$GeneralGenres= do.call(rbind, GeneralGenres)
dfObjectiveOnly = dfObjectiveOnly %>% select(-Genres)
```


## PCA
First the dataset with the complete set of spotify measures was plugged into pca. The proportion of the variance captured in each principle component is seen in the summary. Will look at the rotation of the PC's to see the loadings of the PC's to each feature. Ths will be done to really define each principle component. 
```{r}
pcaOfData = function(df){
  ids = df[,1]
  dfSub = df[,-1]
  pcas = prcomp(dfSub, center = TRUE, scale. = TRUE)
  plot(pcas)
  pcas$x = cbind(ids, data.frame(pcas$x))
  return (pcas)
}
```

First, PCA was applied to the smaller subest of averages only of the spotify metrics. 
```{r}
pcsSpotifySubMetrics = pcaOfData(dfSpotifySubMetrics)
#summary(pcsSpotifySubMetrics)
pcsSpotifySubMetrics$rotation[,1:5]
```
Here we will define that the PC's as follows:
- PC1: How low energy, and acoustic an album is
- PC2: Relatively neutral and poorly defined component
- PC3: How very likely something is a live album
- PC4: How instrumentally heavy and speech heavy an album is
- PC5: How live, instrumental, and happy an album is



Next, PCA was applied to the larger collection of functions of the spotify metrics. 
```{r}
pcsSpotifyAll = pcaOfData(dfSpotifyAllMeasures)
#summary(pcsSpotifyAll)
pcsSpotifyAll$rotation[,1:5]
```
Here we will define that the PC's as follows:
- PC1: How acoustic, and generally low energy and mellow an album is 
- PC2: The levels of dancability and speechiness are unimportant in defining this PC, but energy and loudness may 
- PC3: Not measuring live albums, but how happy and dancable an album may be
- PC4: Very strongly measuring the max instrumentalness and range of instrumentalness in an album, as well as somewhat how dancable
- PC5: How sad and speechy an album is with a low range of energy


Next, PCA was applied to the data with all spotify metrics and the objective average metrics. 
```{r}
pcsSpotifyAndObjectives = pcaOfData(dfSpotifyAndMusicData)
pcsSpotifyAndObjectives$rotation[,1:5]
```
Here we will define that the PC's as follows:
- PC1: Measure of how explicit an album is compiled with how dancable and speechy it is, potentially a score of something being a rap album
- PC2: Measure of how low energy, low volume, high dynamic, and acoustic an album is.
- PC3: How short an album is, with also measuring how acoustic and dancable it is.
- PC4: Measure of how long, instrumental, happy, and dancable an album is that is not live
- PC5: Measure of how short, explicit, instrumental, slow, and sad an album is.


Next, PCA will be applied to all of our data.  TODO:Need to dummify the categorical vars



## K-Means Clustering and Case Studies
What will really be focused on here is the clustering of the PC's as this will reduce the affect of the noise. 
```{r}
kMeansPipeline = function(df, numClusts){
  dataSub = as.data.frame(df)
  dataSub = dataSub[,-1]
  wss <- (nrow(dataSub)-1)*sum(apply(dataSub,2,var))
  for (i in 2:50) wss[i] <- sum(kmeans(dataSub,centers=i)$withinss)
  plot(1:50, wss, type="b", xlab="Number of Clusters",
       ylab="Within groups sum of squares")
  
  k <- kmeans(dataSub, numClusts,iter.max=1000)
  clustDf = as.data.frame(df)
  clustDf$cluster = as.factor(k$cluster)
  return(clustDf)
}
```

```{r}
artistClusterCount = function(clusterData){
  artistCounts = clusterData %>%
    separate(id, c("Album", "Artist"), "---") %>%
    select(Artist, cluster) %>%
    group_by(cluster, Artist) %>%
    summarise(countInClusts = n())
  return(artistCounts)
}
```

A function will be created to join the demographic and objective data back to the album names once they have been clustered. This will allow us to see the prevalence of traits in particular clusters. 
```{r}
###Function to rejoin two datasets
reattachData = function(clustData, objectiveData){
  newData = clustData %>%
    inner_join(objectiveData, by = "id") %>%
    distinct()
  return(newData)
}

## Groupby to count
countInClusters = function(df, cols){
  counts = df %>%
    group_by(cluster, !!!syms(cols))%>%
    summarise(countInClusts = n()) %>%
    unite(Group, cols)
  print(counts)
  return(counts)
}


# chains previous functions to make stacked bar charts showing the proportions of each group for each cluster
stackedBarByClust = function(df, vals) {
  reattachData = reattachData(df, dfObjectiveOnly)
  countOfReattached = countInClusters(reattachData, vals)
  valProportionsReattached = countOfReattached %>%
    group_by(cluster) %>%
    mutate(proportion = countInClusts/sum(countInClusts))
  
  ggplot(valProportionsReattached, aes(x = cluster, y =proportion, fill = Group), na.rm =TRUE) +
    geom_bar(position = "fill",stat = 'identity', na.rm = TRUE) +
    labs(x = "Cluster", y = "Proportion", title = paste("Distribution of ",  paste(vals, collapse = " and ") ," In Each Cluster", sep = ""))
}

```


Now functionality will be made to get average for given values in each cluster. 
```{r}
#Function to show an average metric in each cluster
avgMetricsinClusts = function(dfInput, vals){
  reattached = reattachData(dfInput, df)
  processedData = reattached %>%
    select(cluster, vals) %>% 
    mutate_at(vars(vals), funs(scale)) %>%####Values standardized before groupby and mean
    group_by(cluster) %>%
    summarise_at(vars(vals), mean) %>%
    gather(key= "Attribute", value = "Value", vals)
  
  
  ggplot(processedData, aes(x = cluster, y =Value, fill = Attribute), na.rm =TRUE) +
    geom_bar(stat="identity",position = "dodge", na.rm = TRUE) +
    labs(x = "Cluster", y = "Average Value", title = paste("Average  ",  paste(vals, collapse = " and ") ," in Each Cluster", sep = ""))
}

```


The principle components of only the average spotify metrics are clustered. 
```{r}
pcaSpotifySubClusters = kMeansPipeline(data.frame(pcsSpotifySubMetrics$x[,1:3]), 5)
#pcaSpotifySubClusters
plot(pcsSpotifySubMetrics$x[,2:3], col=pcaSpotifySubClusters$cluster, pch=16)
```

```{r}
spotifySubReattached = reattachData(pcaSpotifySubClusters, dfObjectiveOnly)
#print(spotifySubReattached)
a = countInClusters(spotifySubReattached, c("Gender"))
print(a)
```



```{r}
artistCount=artistClusterCount(pcaSpotifySubClusters)
johnMayerAppearances = artistCount %>%
  filter(Artist == "John Mayer")
print(johnMayerAppearances)

maroon5Appearances = artistCount %>%
  filter(Artist == "Maroon 5")
print(maroon5Appearances)
```


The principle components of the complete set of spotify metrics are clustered here using k-means. 
```{r}
pcaSpotifyAllClusters = kMeansPipeline(data.frame(pcsSpotifyAll$x[,1:3]), 5)
#pcaSpotifyAllClusters
plot(pcsSpotifyAll$x[, c(2,3)], col=pcaSpotifyAllClusters$cluster, pch=16)
#clustDf = clustDf[order(clustDf$cluster),]
```
```{r}
artistCount=artistClusterCount(pcaSpotifyAllClusters)
johnMayerAppearances = artistCount %>%
  filter(Artist == "John Mayer")
print(johnMayerAppearances)

maroon5Appearances = artistCount %>%
  filter(Artist == "Maroon 5")
print(maroon5Appearances)
```




The principle components of the complete set of spotify metrics and the objective measures are clustered here using k-means. 
```{r}
pcaSpotifyAllCompleteClusters = kMeansPipeline(data.frame(pcsSpotifyAndObjectives$x[,1:4]), 5)
#pcaSpotifyAllCompleteClusters
plot(pcsSpotifyAndObjectives$x[, c(3,4)], col=pcaSpotifyAllCompleteClusters$cluster, pch=16)
#clustDf = clustDf[order(clustDf$cluster),]
#pcaSpotifyAllCompleteClusters
```

```{r}
artistCount=artistClusterCount(pcaSpotifyAllCompleteClusters)
johnMayerAppearances = artistCount %>%
  filter(Artist == "John Mayer")
print(johnMayerAppearances)

maroon5Appearances = artistCount %>%
  filter(Artist == "Maroon 5")
print(maroon5Appearances)
```


```{r}
avgMetricsinClusts(pcaSpotifyAllCompleteClusters, c("avgDanceability", "avgEnergy", "avgAcousticness", "avgSpeechiness", "avgInstrumentalness", "presenceUncommonTS", "proportionExplicit", "avgLiveness", "avgValence", "rangeValence"))
avgMetricsinClusts(pcaSpotifyAllCompleteClusters, c("avgEnergy", "avgAcousticness"))
avgMetricsinClusts(pcaSpotifyAllCompleteClusters, c("avgSpeechiness", "proportionExplicit"))
avgMetricsinClusts(pcaSpotifyAllCompleteClusters, c("numGrammys", "presenceUncommonTS"))
avgMetricsinClusts(pcaSpotifyAllCompleteClusters, c("numSongsOnAlb", "totalExplicit", "NumAlbums"))
avgMetricsinClusts(pcaSpotifyAllCompleteClusters, c("avgLoudness", "rangeLoudness"))
```


```{r}
stackedBarByClust(pcaSpotifyAllCompleteClusters, c("Gender"))
stackedBarByClust(pcaSpotifyAllCompleteClusters, c("Group.Solo"))
stackedBarByClust(pcaSpotifyAllCompleteClusters, c("ReleaseYear"))
#stackedBarByClust(pcaSpotifyAllCompleteClusters, c("Gender", "Group.Solo"))
#stackedBarByClust(pcaSpotifyAllCompleteClusters, c("Gender", "ReleaseYear"))
#stackedBarByClust(pcaSpotifyAllCompleteClusters, c("Group.Solo", "ReleaseYear"))
```


